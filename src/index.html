<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title><%= htmlWebpackPlugin.options.title %></title>
    <link rel="icon" type="image/png" href="favicon.png">
  </head>
  <body>
  <!-- <h1>React</h1> -->


<div id="MainInterface">

</div>

<div id="app"></div>

<div class="notes">
<div class="section">
  <h2>React the notes</h2>
  <li>A la base on a juste un render a lancer pour avoir du jsx a l ecran</li>
  <li>
React.createClass vs extends React.Component voir lien ici : :::::<a href="http://stackoverflow.com/documentation/reactjs/6371/react-createclass-vs-extends-react-component#t=201611112010580710903"></a></li>
<li>seulement un container doit etre retourné.</li>
<li> componentDidMount est une maniere d 'avoir acces au debut '</li>
<li>lui suggere de faire une variable avec nos props et les pointer vers this. props. valeur et dans le jsx utiliser que le nom de variable, ca fait du sens... </li>
<li>Les refs: permet de mettre un hook, pour acceder a un tag, et en tirer sa valeur par exemple. refs est un objet, et on accede a ses nom par dot notation</li>
<li>le state est l objet qui produit un refresh, doit etre creer d'avance, les props eux se font initialiser dans le render , sont read only, et mis sur le component terminé, le state est dans le corps du component et est read , write. BRef un component ne modifie pas ses props, mais modifie continuellement son state.</li>
<li>On les creer avec getInitialState en createClass, en es6, juste l object dans le constructor.</li>
<li>il est possible de faire des raccorci, puisque props est une onbjet let p = this.props , ensuite p.nom == this.props.nom</li>
<li>deux function sont importante ici a present.getInitialState et  getInitialState, function qui return un obj de key -> value</li>

</div>

<div class="section">
  <h2>Animer React avec Tweenmax</h2>
  <li>Dans componentDidMount, on doit selectionner le node ( le contenant unique du component)  node = ReactDOM findDOMNode (this) </li>
  <li>pour animer qu un seul des children, on doit le trouver ndas l index de children. et en faire une variable.</li>
  <li>Ensuite , meme chose qued habite avec GSAP</li>
</div>


<div class="section">
  <h2>Suite React, avoir plusieurs components</h2>
  <li>Quand et ou diviser ses components, ici la form devrait etre ailleurs, le greeting, l autre.</li>
  <li>il est suggere de faire une version statique bien divisee au depart et ensuite ajouter les fonctionnalites.</li>
  <li>Decider si prop ou state: simplement se demander si une valeur sera modifiee, si oui, STATE, sinon, props.</li>
</div>

<div class="section">
  <h2>Envoyer du data d'un component externe au container</h2>
  <li>Le container doit par exemple, sur un onchange, ou submit, appeler une function locale, cette fonction locale elle doit traiter le data une fois fait, doit la passer au container (on parle du component prinicipale) par un propriete, une prop.  </li>
  <li>dans l'externe on a ici par exemple une fonction onFormSubmit , cette fonction pour envoyer ca au container  a l'aide d une props function </li>
  <li>dans l'instance du component externe dans le container   nomducomponentexterne  on y met une props qui elle meme lance une function locale sur le contianer, qui change le state pour creer l ajustement , le rafraichissement.   </li>
</div>

<div class="section">
  <h2>Presention component VS container component</h2>
  <li>Un presentation component est un componenet sans state, il ne fait qu afficher ses props.</li>
  <li>un container compo. lui a ses state et va avoir les methodes qui s en suivent</li>
  <li>Si on contruit un objet pour les valeurs de state a changer, au lieu de faire des key value, on peut passer l object complet.</li>

</div>

<div class="section">
  <h2>division des components</h2>
  <li>Il devient plus facile de lire les fichieers une fois separe. faire un folder component, ensuite , importer react dans les fichiers du meme nom que les component</li>
  <li>des const doivent se faire exporter au debut sans default ou a la fin avec le default, et non pas au moment de sa creation avec default. default est un seul export par module</li>

</div>

<div class="section">
  <h2>Routing</h2>
  <li>le contenant est le Router, dans lui des routes , et les route sont logique a l ecran, dans le main,si on veut garder, mais aller a une autre page qui demande a ce que main reste, on fait le lien entre les deux bout de main et y mettre  /about. l autre props est component et appelle le nom du component que l on veut a ce path. </li>
  <li>IndexRoute, est pour celui par defaut si on veut, si le hash n'est pas juste, mettons que je tape abOt au lieu d about, ca ira a l index route. Compliquer, mais si on avait que des route, le / ne chargerait rien, mais la il a un children , dans l indexroute. Donc le indexroute devient le par defaut... avec indexroute s appelait defaultroute.. ce qui etait plus clair</li>
  <li>Link au lieu de a link, en majuscule le link, mais il est possible d'utiliser des a avec href de #/about , et ca fera le meme chemin. On utilise Link parce que nous avons la possibilite de stylyser specifiquement pour la page que l on veut.</li>
  <li>Aussi avec actviveClass, on peut determiner le defaut, et le style. </li>
  <li>Quand on utilise indexRoute, dans le router, sur le component en question, le lien du nav sera toujours actif avec Link, il faut utiliser indexLink</li>

</div>

<div class="section">
  <h2>Es6 promises</h2>
  <li>Voici un leger rappel sur les promesses</li>
  <pre><code>

     function addPromesse(a,b){
      return new Promise((res,rej) => {
        if ((typeof a === 'number') && (typeof b === 'number')) {
             res( a + b)  //ce que l on fait avec les deux var.
        } else {
          rej (' erreur')
        }
      }) ;
     }

     addPromesse(2,21).then(sum => {
       console.log(sum)
     }).catch(err => {
       console.log(err)
     })

     addPromesse(2,"b").then(sum => {
       console.log(sum)
     }).catch( err => {
       console.log('oups' + err )
     })
  </code></pre>
</div>

<div class="section">
  <h2>Linker tout..</h2>
  <li>La form onsubmit lance un func qui elle valide le data, et l envois a une func qui sera une props sur l elelment, qui elle meme lancera un handleSearch. elle recoit le data, et ici deviendra un state, et pour modifier, il faut des states.</li>
  <li>Ces state la pour les passer, on utilise la destrucration = le state, et le passe en props. le componenet qui recoit, peut lui aussi destructurer les state, mais rendu la , ils sont des props. Je me comprendrai jamais. </li>
  <pre><code>

  </code></pre>
</div>


<div class="section">
  <h2>Le fetch API</h2>
  <li>le point du fetch, c est qu il recoit du data, mais il sait pas quoi,  res.json()  est la cle et fait l object. </li>
  <li>ensuite on suit le chemin tout simplement vers ce que l on a de besoin.</li>
  <pre><code>


  return fetch(requestUrl)
  .then(function(res){
    return res.json()  //mets le blob en json
  }).then(res => {
    if(res.cod && res.message){
      throw new Error(res.message)
    } else {
    console.log(res)
   return Math.round(res.main.temp)   //patch d anl object.
  }}).catch(err => {
       console.log(err)    //si err.
    });
  }
getTemp('laval') retourne 22 ..

  </code></pre>
</div>


<div class="section">
  <h2>Retourner conditionnelement son jsx</h2>
  <li>il est possible de decider si on retourne ci ou ca, avec une function dans la portion render, avant le return. </li>
  <li>ca peut etre tel compoenent, ou celui la, il s agit seulement dnas le return entre parenthese jsx, de lancer la fu nction qui fait le if, et determine quoi montrer</li>
  <li></li>
</div>

<div class="section">
  <h2>Ajout des source-maps</h2>
  <li>Dans config de webpack   devtool: 'source-map' nous donne maintenant notre code dans la console et pas le code transformé, ca deveient bcp plus simple pour les erreurs.</li>

</div>

<div class="section">
  <h2>Stateless functionnal component</h2>
  <li>Qaund un componenet est plus simple, il est preferable d utiliser un SFC. </li>
  <li>on ne peut y mettre de refs, de methode de lifecycle non plus, snapppp. </li>
  <pre><code>

  </code></pre>
</div>

<div class="section">
  <h2>GIT</h2>
  <li>Pour installer git, dans le folder du project, taper git init dans le terminal , un fichier sera creer, qu on voit pas</li>
  <li>git status, permet de voir ou en est le git, et au depart aucun fichier n'est surveille, on ne veut seulement pas node-moudle</li>
  <li>.gitignore que l on doit creer au root, et y mettre ce qu'on ne veut pas tracker : .DS_Store , bs-config.json et node_modules/</li>
  <li>Si on relance git status, ceux ci ne sont plus present</li>
  <li>Maintenant pour faire un commit, on tape:  git add .gitignore pour ajouter a la liste verte se fichier.</li>
  <li>Maintenant pour eviter d avoir a tout taper, on peut seulement taper : GIT ADD .  avec le point, on ajoute tous les fichier non-black listé par le git ignore. refaire git status pour voir</li>
  <li>Tout est maintenant vert.Mais rien a raiment savé</li>
  <li>Maintenant pour sauvegarder : en minuscule: GIT COMMIT -m 'Commit Initial' , dans le string, on met simplement un description, si mose ajour , bug reparation, ou peu importe.</li>
  <li>la liste des fichiers sera a l ecran , refaire git status et la liste des fichier modifiers depuis y sera, icil index a changer parce que je tappe, et celui, le index fait par webpack aussi... </li>
  <li>Donc chaque fois qu on touche un fichier, il s ajoutera a la liste pas updatees rouge.</li>
  <li>on pourrait rfaire les memes etapes, mais : GIT COMMIT -A -M 'UPDATE' ,  </li>
  <pre><code>

  </code></pre>
</div>


</div>

</body>
</html>
